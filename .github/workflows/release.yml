name: Package Firefox extension

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g. v1.0.0)'
        required: true
      name:
        description: 'Release name (optional)'
        required: false
  push:
    tags:
      - 'v*'
    branches:
      - master

jobs:
  package:
    name: Build and publish XPI
    runs-on: ubuntu-latest
    if: >-
      startsWith(github.ref, 'refs/tags/') ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && contains(github.event.head_commit.message, '[release]'))
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine tag and names
        run: |
          if [ -n "${{ github.event.inputs.tag }}" ]; then TAG="${{ github.event.inputs.tag }}"; else TAG="${GITHUB_REF##*/}"; fi
          NAME="${{ github.event.inputs.name }}"
          if [ -z "$NAME" ]; then NAME="$TAG"; fi
          ZIPNAME="FirefoxPriceTracker-${TAG}.zip"
          echo "TAG=$TAG" >> $GITHUB_ENV
          echo "NAME=$NAME" >> $GITHUB_ENV
          echo "ZIPNAME=$ZIPNAME" >> $GITHUB_ENV

      - name: Ensure zip is available
        run: sudo apt-get update && sudo apt-get install -y zip

      - name: Create ZIP package
        run: |
          rm -f "$ZIPNAME"
          zip -r "$ZIPNAME" . -x ".github/*" ".git/*" "README.md" "LICENSE" ".gitignore" ".vscode/*"

      - name: Install web-ext
        run: npm install --global web-ext

      - name: Show files and icons (debug)
        run: |
          echo "--- root listing ---"
          ls -la
          echo "--- icons listing ---"
          ls -la icons || true
          echo "--- find icon files ---"
          find . -maxdepth 3 -name 'icon-*.png' || true
          echo "--- manifest ---"
          cat manifest.json || true

      - name: Build extension with web-ext (debug)
        run: |
          if command -v web-ext >/dev/null 2>&1; then
            web-ext build --source-dir . --artifacts-dir build || npx web-ext build --source-dir . --artifacts-dir build
          else
            npx web-ext build --source-dir . --artifacts-dir build
          fi
          echo "Built artifacts:"; ls -la build || true

      - name: Ensure built artifact is XPI
        run: |
          # If web-ext produced a .zip, convert/rename it to .xpi so signing uses the packaged artifact
          set -euo pipefail
          ZIPFILE=$(ls build/*.zip 2>/dev/null | head -n1 || true)
          if [ -n "$ZIPFILE" ]; then
            XPIFILE="${ZIPFILE%.zip}.xpi"
            if [ ! -f "$XPIFILE" ]; then
              echo "Renaming $ZIPFILE -> $XPIFILE"
              mv "$ZIPFILE" "$XPIFILE"
            else
              echo "XPI already exists: $XPIFILE"
            fi
          else
            echo "No build/*.zip found; leaving build/ as-is"
          fi
          echo "build/ contents:"; ls -la build || true


      - name: Sign XPI with AMO (JWT)
        env:
          WEB_EXT_JWT_ISSUER: ${{ secrets.AMO_JWT_ISSUER }}
          WEB_EXT_JWT_SECRET: ${{ secrets.AMO_JWT_SECRET }}
        run: |
          set -euo pipefail
          # If secrets missing, skip AMO submission but continue (we still upload the built ZIP to GitHub)
          if [ -z "${WEB_EXT_JWT_ISSUER:-}" ] || [ -z "${WEB_EXT_JWT_SECRET:-}" ]; then
            echo "INFO: AMO JWT secrets not set (AMO_JWT_ISSUER / AMO_JWT_SECRET). Skipping AMO submission."
          else
            echo "Attempting to submit to AMO for signing (we will not download the signed XPI)"
            echo "Looking for built XPI in build/"
            ls -la build || true
            XPI_TO_SIGN="$(ls build/*.xpi 2>/dev/null | head -n1 || true)"
            # Some versions of `web-ext` do not accept a `--xpi` flag; submit the source-dir
            # to AMO instead (this will submit the same packaged data and ensures icons are included).
            echo "Submitting source-dir to AMO for signing (artifacts will be written to signed/)"
            # run sign and do not fail the job if AMO reports a conflict or other non-fatal error
            npx web-ext sign --api-key "$WEB_EXT_JWT_ISSUER" --api-secret "$WEB_EXT_JWT_SECRET" --channel unlisted --source-dir . --artifacts-dir signed 2>&1 | tee webext-sign.log || true
            echo "--- web-ext sign log (tail) ---"
            tail -n 200 webext-sign.log || true
            echo "Note: we do not download or attach the signed XPI in this workflow."
          fi


      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: ${{ env.TAG }}
          release_name: ${{ env.NAME }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN || github.token }}

      - name: Update AMO listing (optional)
        env:
          AMO_JWT_ISSUER: ${{ secrets.AMO_JWT_ISSUER }}
          AMO_JWT_SECRET: ${{ secrets.AMO_JWT_SECRET }}
        run: |
          echo "Updating AMO listing using release/amo-metadata.json"
          if [ ! -f release/amo-metadata.json ]; then
            echo "release/amo-metadata.json not found; skipping AMO update"; exit 0
          fi
          SLUG=$(python3 -c "import json,sys;print(json.load(open('release/amo-metadata.json')).get('addon_slug',''))")
          if [ -z "$SLUG" ]; then echo "addon_slug missing in release/amo-metadata.json; skipping"; exit 0; fi
          echo "Preparing auth header for AMO via JWT"
          if [ -z "${AMO_JWT_ISSUER:-}" ] || [ -z "${AMO_JWT_SECRET:-}" ]; then
            echo "AMO JWT credentials not present; skipping AMO update"
            exit 0
          fi
          echo "AMO_JWT_ISSUER: ${AMO_JWT_ISSUER}"
          python3 -m pip install --quiet PyJWT
          # generate short-lived JWT and expose it as JWT_TOKEN
          JWT_TOKEN=$(python3 -c "import os,time,uuid,jwt; iss=os.environ.get('AMO_JWT_ISSUER'); secret=os.environ.get('AMO_JWT_SECRET'); iat=int(time.time()); payload={'iss':iss,'jti':str(uuid.uuid4()),'iat':iat,'exp':iat+60}; token=jwt.encode(payload,secret,algorithm='HS256'); print(token.decode('utf-8') if isinstance(token,bytes) else token)")
          echo "JWT generated (not printing token)"
          # Show decoded JWT payload for diagnostics (no secret printed)
          python3 - <<'PY'
import os, jwt
tok = os.environ.get('JWT_TOKEN')
if tok:
    try:
        payload = jwt.decode(tok, options={'verify_signature': False})
        print('JWT payload:', payload)
    except Exception as e:
        print('Failed to decode JWT payload:', e)
else:
    print('JWT_TOKEN not set')
PY
          # Test GET access to the add-on with the generated token
          echo "Checking AMO GET /addons/addon/$SLUG/ with JWT auth"
          HTTP_STATUS=$(curl -s -o amo-get.json -w "%{http_code}" -H "Authorization: JWT ${JWT_TOKEN}" "https://addons.mozilla.org/api/v5/addons/addon/$SLUG/" || true)
          echo "AMO GET status: $HTTP_STATUS"
          echo "AMO GET body:"; cat amo-get.json || true
          echo "Attempting PATCH to update listing (show full response)"
          curl -i -s -X PATCH "https://addons.mozilla.org/api/v5/addons/addon/$SLUG/" \
            -H "Authorization: JWT ${JWT_TOKEN}" \
            -H "Content-Type: application/json" \
            --data-binary @release/amo-metadata.json | tee amo-update.log || true
          echo "AMO update (tail):"; tail -n 200 amo-update.log || true

      - name: Upload ZIP to release
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ env.ZIPNAME }}
          asset_name: ${{ env.ZIPNAME }}
          asset_content_type: application/zip
        env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN || github.token }}
